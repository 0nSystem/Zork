"""[summary]

    This file provides several functions that creates the
    command line compiler calls, generated after parsing the
    Zork config file and retrieve the data
"""

import glob
import os
import subprocess

from program_definitions import CLANG, GCC, MSVC
from utils.exceptions import LanguageLevelNotEnought, UnsupportedCompiler


def build_project(config: dict, verbose: bool, project_name: str) -> int:
    """ Calls the selected compiler to perform the build of the project """

    generate_build_output_directory(config)

    compiler = config['compiler'].cpp_compiler
    command_line: list = []

    if compiler == CLANG:
        command_line = call_clang_to_compile(config, verbose, project_name)
    elif compiler == GCC:
        raise UnsupportedCompiler(GCC)
    else:
        raise UnsupportedCompiler(MSVC)

    # if verbose:
    print(f'Command line to execute: {" ".join(command_line)}\n')

    return subprocess.Popen(command_line).wait()


def call_clang_to_compile(config: dict, verbose: bool, project_name: str):
    """ Calls Clang++ to compile the provide files / project """
    # Generates the compiler and linker calls
    command_line = [
        config.get('compiler').cpp_compiler,
        '--std=c++' + config.get('language').cpp_standard,
        '-stdlib=' + config.get('language').std_lib,
        '-o',
        f'{config.get("build").output_dir}/' +
        f'{config.get("executable").executable_name}'
        .replace(
            '<autogenerated_executable>',
            project_name
        )
    ]

    for source in config.get("executable").sources:
        command_line.append(source)

    # Generates a compiler call to prebuild the module units, in case that
    # the attribute it's present, have a valid path to the .cppm module units
    # and the language level it's at least, c++20.
    if config['language'].modules == 'true':
        if int(config.get('language').cpp_standard) < 20:
            raise LanguageLevelNotEnought(
                20,
                config.get('language').cpp_standard,
                "Modules"
            )

        prebuild_modules_path, interfaces = _clang_prebuild_module_interfaces(
            config, verbose, project_name
        )
        implementations = _compile_module_implementations(
            config, verbose, project_name, prebuild_modules_path
        )

        for module_ifc in interfaces:
            command_line.append(module_ifc)
        for module_src in implementations:
            command_line.append(module_src)

        command_line.append(
            f'-fprebuilt-module-path={prebuild_modules_path}'
        )

    return command_line


def _clang_prebuild_module_interfaces(
    config: dict,
    verbose: bool,
    project_name: str
) -> list:
    """ The responsable for generate de module units
        for the C++20 modules feature.
        Returns a list with the args that should be passed into them
        main compiler call in order to enable the modules compilation
        and linkage """
    output_dir: str = config['build'].output_dir
    modules_dir_path = output_dir + '/modules'
    module_ifcs_dir_path = modules_dir_path + '/interfaces'

    if verbose:
        print('Precompiling the module interfaces...')
    # Generate the precompiled modules directory if it doesn't exists
    if 'modules' not in os.listdir(output_dir):
        subprocess.Popen(['mkdir', modules_dir_path]).wait()
        subprocess.Popen(['mkdir', module_ifcs_dir_path]).wait()

    module_ifcs: list = _get_ifcs(config, project_name)
    print(f'MODULE IFCS: {module_ifcs}')

    for module in module_ifcs:
        # Strips the path part if the module name it's inside a path,
        # (like 'src/inner/module_file_name.cppm') and not alone,
        # as a *.cppm file. Also, strips the file extension for
        # replace it the file name ext for the .pcm one
        module_name: str = module
        if module.__contains__('/'):
            module_dir_parts_no_slashes: list = module.split('/')
            module_name = \
                module_dir_parts_no_slashes[
                    len(module_dir_parts_no_slashes) - 1
                ]
            module_name_no_extensions = ''.join(module_name.split('.')[0])
            module_name: str = module_name_no_extensions

        commands: list = [
                config.get("compiler").cpp_compiler,
                '-c',
                '--std=c++' + config.get("language").cpp_standard,
                '-stdlib=' + config.get("language").std_lib,
                '-Xclang',
                '-emit-module-interface',
                '--precompile',
                '-o', f'{module_ifcs_dir_path}/{module_name}.pcm',
                module
            ]
        if not module.__contains__(".cppm"):
            commands.append('-Xclang')
            commands.append('-emit-module-interface')

        print(f'MIU Command line to execute: {" ".join(commands)}\n')
        subprocess.Popen(commands).wait()

    if verbose:
        print(
            '...\nPrecompilation of module interface units finished!'
        )

    precompiled_mod_ifcs: list = [
        pmiu for pmiu in glob.glob(f'{module_ifcs_dir_path}/*.pcm')
    ]

    return module_ifcs_dir_path, precompiled_mod_ifcs


def _compile_module_implementations(
    config: dict,
    verbose: bool,
    project_name: str,
    module_ifcs_dir_path: str
):
    """
        Compiles the module implementation units, when the declaration
        it's splitted from the implementation, usually in interface file
        and implementation file.

        This process needs to know about the prebuild module interface
        units, and point the implementation unit to the correct
        module interface file.
    """
    if verbose:
        print('Compiling the module implementations...')

    commands: list = [
        config.get('compiler').cpp_compiler,
        '-c',
        '--std=c++' + config.get('language').cpp_standard,
        '-stdlib=' + config.get('language').std_lib,
    ]

    module_impls: list = _get_impls(config, project_name)

    print(f'MODULES IMPL: {module_impls}')

    for module_impl in module_impls:
        # Generates the path for the special '**' Zork syntax
        commands.append(module_impl.replace('\\', '/'))
        mod = module_impl \
            .replace('\\', '/') \
            .split('/')

        mod2 = mod[(len(mod) - 1)] \
            .split('.')[0]

        commands.append('-o')
        commands.append(f'{module_ifcs_dir_path}/{mod2}.o')
        commands.append(
            f'-fmodule-file={module_ifcs_dir_path}/{mod2}.pcm'
        )

    # print(f'COMMANDS: ...\n {commands}')
    print(f'MImplU Command line to execute: {" ".join(commands)}\n')
    subprocess.Popen(commands).wait()
    # print('Success MImplU')

    if verbose:
        print('...\nModule implementation units compilation finished!')

    precompiled_mod_ifcs: list = [
        pmiu for pmiu in glob.glob(f'{module_ifcs_dir_path}/*.o')
    ]

    return precompiled_mod_ifcs


def _get_ifcs(config: dict, project_name: str):
    """ Gets the sources files for both declaration
    (interface) files
    """
    mods_from_config: list = config.get('modules').interfaces
    mods: list = []

    print(f'mods_from_config_file: {mods_from_config}')

    if len(mods_from_config) == 1:
        # By default, the **.ext notation works with restrictions,
        # only finding modules on the ./{project_name}/ifc/{file_name}.{ext}
        _path = f'./{project_name}/ifc/*.' + \
            mods_from_config[0].split('.')[1]  # file ext
        print(f'_path: {_path}')
        for wildcarded_source in glob.glob(_path):
            mods.append(wildcarded_source.replace('\\', '/'))
    else:
        print('ELSE')
        mods_user_paths: list = config.get('modules').interfaces_dirs
        print(f'PATHS: {mods_user_paths}')
        if mods_user_paths != []:
            for path in mods_user_paths:
                for interface in glob.glob(path):
                    mods.append(f'{path}/{interface}')

    print(f'IFCS: {mods}')
    return mods


def _get_impls(config: dict, project_name: str):
    """ Gets the sources files for both declaration
    (interface) files
    """
    mods_from_config: list = config.get('modules').interfaces
    mods: list = []

    if len(mods_from_config) == 1:
        # By default, the **.ext notation works with restrictions,
        # only finding modules on the ./{project_name}/src/{file_name}.{ext}
        _path = f'./{project_name}/src/*.' + \
            mods_from_config[0].split('.')[1]  # file ext
        for wildcarded_source in glob.glob(_path):
            mods.append(wildcarded_source.replace('\\', '/'))
    else:
        mods_user_path: list = config.get('modules').interfaces_dirs

        if mods_user_path != []:
            for path in mods_user_path:
                for implementation_file in glob.glob(path):
                    mods.append(f'{path}/{implementation_file}')

    return mods


def generate_build_output_directory(config: dict):
    """ Creates the directory where the compiler will dump the
        generated files after the build process """
    output_build_dir = config['build'].output_dir
    if not output_build_dir.strip('./') in os.listdir():
        subprocess.Popen(['mkdir', output_build_dir]).wait()
