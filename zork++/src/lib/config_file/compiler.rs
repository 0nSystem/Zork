use core::fmt;

///! file for represent the available configuration properties within Zork++
///! for setting up the target compiler
///
/// ## TODO LIST
///! TODO -> Convert this attribute into a collection of this attribute,
/// allowing Zork++ to compile one project for multiple compilers
/// at the same time
use serde::Deserialize;

/// [`CompilerAttribute`] - Configuration properties for
/// targeting one of the available compilers within Zork++
///
/// * `cpp_compiler` - One of the available compilers within Zork++
/// They are represented by an enumerated type named [`CppCompiler`],
/// that holds the different options where the user can choose
///
/// * `cpp_standard` - An string defining the version of the ISO
/// C++ standard that should be used on the compilation process
///
/// * `std_lib` - The concrete C++ standard library (vendor specific)
/// to link the builded code against
///
/// * `extra_args` - A comma separated list of strings that will be passed
/// to the generated command lines. This ones here will be placed in every
/// command line generated by Zork++.
/// For example, if *['-O3', '-Wall']*
/// are included here, this will be wired in the main command line (the executable),
/// the ones generated for compile modules (both interfaces and implementations)
/// and for the command line generated for build the specified test suite and
/// the test executableÃ§
///
/// * `system_headers_path` - An string indicating a user custom defined place
/// where the system headers lives.
///
/// ### Tests
///
/// ```rust
/// use zork::config_file::compiler::{
///     CompilerAttribute, CppCompiler, LanguageLevel, StdLib
/// };
///
/// const CONFIG_FILE_MOCK: &str = r#"
///     #[compiler]
///     cpp_compiler = 'CLANG'
///     cpp_standard = '20'
///     std_lib = 'libcpp'
///     extra_args = ['-O3', '-Wall']
///"#;
///
/// let config: CompilerAttribute = toml::from_str(CONFIG_FILE_MOCK)
///    .expect("A failure happened parsing the Zork toml file");
///
/// assert_eq!(config.cpp_compiler, CppCompiler::CLANG);
/// assert_eq!(config.cpp_standard, LanguageLevel::CPP20);
/// assert_eq!(config.std_lib, Some(StdLib::LIBCPP));
/// assert_eq!(config.extra_args, Some(vec!["-O3", "-Wall"]));
/// assert_eq!(config.system_headers_path, None);
/// ```
///
/// > Note: TOML table are toml commented (#) to allow us to parse
/// the inner attributes as the direct type that they belongs to.
/// That commented tables aren't the real TOML, they are just there
/// for testing and exemplification purposes of the inner attributes
/// of the configuration file.
///
/// For a test over a real example, please look at the
/// [`zork::config_file::ZorkConfigFile`] doc-test
#[derive(Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
pub struct CompilerAttribute<'a> {
    pub cpp_compiler: CppCompiler,
    pub cpp_standard: LanguageLevel,
    pub std_lib: Option<StdLib>,
    #[serde(borrow)]
    pub extra_args: Option<Vec<&'a str>>,
    #[serde(borrow)]
    pub system_headers_path: Option<&'a str>,
}

/// The C++ compilers available within Zork++
#[derive(Deserialize, Debug, Clone, PartialEq)]
pub enum CppCompiler {
    #[serde(alias = "CLANG", alias = "Clang", alias = "clang")]
    CLANG,
    #[serde(alias = "MSVC", alias = "Msvc", alias = "msvc")]
    MSVC,
    #[serde(alias = "GCC", alias = "Gcc", alias = "gcc")]
    GCC, // Possible future interesting on support the Intel's C++ compiler?
}

impl fmt::Display for CppCompiler {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match *self {
            CppCompiler::CLANG => write!(f, "clang"),
            CppCompiler::MSVC => write!(f, "msvc"),
            CppCompiler::GCC => write!(f, "gcc"),
        }
    }
}

impl CppCompiler {
    /// Returns an &str representing the compiler driver that will be called
    /// in the command line to generate the build events
    pub fn get_driver(&self) -> &str {
        match *self {
            CppCompiler::CLANG => "clang++",
            CppCompiler::MSVC => "cl",
            CppCompiler::GCC => "g++",
        }
    }

    pub fn get_default_module_extension(&self) -> &str {
        match *self {
            CppCompiler::CLANG => "cppm",
            CppCompiler::MSVC => "ixx",
            CppCompiler::GCC => "cc",
        }
    }

    pub fn get_typical_bmi_extension(&self) -> &str {
        match *self {
            CppCompiler::CLANG => ".pcm",
            CppCompiler::MSVC => ".ifc",
            CppCompiler::GCC => ".o",
        }
    }
}

/// The C++ ISO standard levels of the language, represented as an
/// enumerated type in Rust
///
/// Variants *2A* and *2B* represents Clang's way of
/// use the latests features available
///
/// Variant *LATEST* is the `MSVC` specific way of set the language
/// standard level to the latest features available in Microsoft's compiler
#[derive(Deserialize, Debug, Clone, PartialEq)]
pub enum LanguageLevel {
    #[serde(alias = "20")]
    CPP20,
    #[serde(alias = "23")]
    CPP23,
    #[serde(alias = "2a")]
    CPP2A,
    #[serde(alias = "2b")]
    CPP2B,
    #[serde(alias = "latest")]
    LATEST,
}

impl LanguageLevel {
    pub fn as_str(&self) -> &str {
        match *self {
            LanguageLevel::CPP20 => "20",
            LanguageLevel::CPP23 => "23",
            LanguageLevel::CPP2A => "2a",
            LanguageLevel::CPP2B => "2b",
            LanguageLevel::LATEST => "latest",
        }
    }

    pub fn as_cmd_arg(&self, compiler: &CppCompiler) -> String {
        match compiler {
            CppCompiler::CLANG | CppCompiler::GCC => format!("-std=c++{}", self.as_str()),
            CppCompiler::MSVC => format!("-std:c++{}", self.as_str()),
        }
    }
}

/// The standard library (compiler specific) that the user
/// desires to link against
#[derive(Deserialize, Debug, Clone, PartialEq)]
pub enum StdLib {
    #[serde(alias = "libstdc++", alias = "gccstdlib", alias = "libstdcpp")]
    STDLIBCPP,
    #[serde(alias = "libc++", alias = "libcpp")]
    LIBCPP,
}

impl StdLib {
    pub fn as_str(&self) -> &str {
        match *self {
            StdLib::STDLIBCPP => "libstdc++",
            StdLib::LIBCPP => "libc++",
        }
    }
}
