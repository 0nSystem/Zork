use crate::config_cli::CppCompiler;
use crate::utils::constans::{INTERFACE_MOD_FILE, MAIN, SRC_MOD_FILE, SRC_MOD_FILE_2, ZORK_CONF};
use log::info;
use std::io::{Write};
use std::path::PathBuf;
use std::process::Command;
use std::str::FromStr;
use std::{
    fs::{DirBuilder, File},
    path::Path,
};

/// Generates a new C++ standarized empty base project
///        with a pre-designed structure to organize the
///        user code in a modern fashion way.
///        Base design for create the project files and folders:
///            - ./ifc/<project_name>
///                - hello_zork.<mod_extension>
///            - ./src/<project_name>
///                - hello_zork.cpp
///            - test
///            - dependencies
pub fn create_template_project(name_template: &str,root_path:&Path, git: bool, compiler: Option<CppCompiler>) {
    // TODO required validate or control optionals
    info!("Create template project");
    let resolved_compiler = compiler.unwrap_or(CppCompiler::CLANG);
    let path_ifc = root_path.join("ifc");
    let path_src = root_path.join("src");
    let path_test = root_path.join("test");
    let path_dependencies = root_path.join("dependencies");

    create_directory(root_path);
    create_directory(&path_ifc);
    create_directory(&path_src);
    create_directory(&path_test);
    create_directory(&path_dependencies);

    let extension_ifcs = match resolved_compiler {
        CppCompiler::CLANG => "cppm",
        CppCompiler::MSVC => "ixx",
        CppCompiler::GCC => "ixx",
    };
    create_file(
        &path_ifc,
        format!("{}.{}", "math", extension_ifcs).as_str(),
        INTERFACE_MOD_FILE.as_bytes(),
    );
    create_file(&path_src, "main.cpp", MAIN.as_bytes());
    create_file(&path_src, "math.cpp", SRC_MOD_FILE.as_bytes());
    create_file(&path_src, "math2.cpp", SRC_MOD_FILE_2.as_bytes());

    let mut zork_conf = ZORK_CONF
        .replace("<project_name>", name_template)
        .replace("<autog_test>", name_template)
        .replace("<autogenerated_executable>", name_template);

    if cfg!(windows) {
        zork_conf = zork_conf.replace("libcpp", "stdlib")
    }
    create_file(
        &PathBuf::from_str(root_path.to_str().expect("Error parsed file to zork.conf"))
            .expect("Not valid path to generate zork.conf"),
        "zork.conf",
        zork_conf.as_bytes(),
    );

    if git {
        let result_git_init = Command::new("git")
            .current_dir(&root_path)
            .arg("init")
            .spawn();

        match result_git_init {
            Ok(_children) => {
                log::info!("Created git repository")
            }
            Err(_) => {
                log::error!("Error create git respotory")
            }
        }
    }
}

fn create_file<'a>(path: &PathBuf, name_file: &'a str, buff_write: &'a [u8]) {
    let mut file = File::create(path.join(name_file)).expect(
        format!(
            "Error create in directory: {}, file: {}",
            path.to_str().expect("Error parsed path in create file"),
            name_file
        )
        .as_str(),
    );
    file.write_all(buff_write).expect(
        format!(
            "Error write in directory: {}, file: {}",
            path.to_str()
                .expect("Error parsed path create file in write"),
            name_file
        )
        .as_str(),
    );
}

fn create_directory(path_create: &Path) {
    DirBuilder::new()
        .recursive(true)
        .create(path_create)
        .expect(
            format!(
                "Error create directory: {}",
                path_create
                    .as_os_str()
                    .to_str()
                    .expect("Error parsed path create directory")
            )
            .as_str(),
        )
}

