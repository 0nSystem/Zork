use crate::config_cli::CppCompiler;
use log::info;
use std::io::Write;
use std::path::PathBuf;
use std::process::Command;
use std::str::FromStr;
use std::{
    fs::{DirBuilder, File},
    path::Path,
};

/// Generates a new C++ standarized empty base project
///        with a pre-designed structure to organize the
///        user code in a modern fashion way.
///        Base design for create the project files and folders:
///            - ./ifc/<project_name>
///                - hello_zork.<mod_extension>
///            - ./src/<project_name>
///                - hello_zork.cpp
///            - test
///            - dependencies
pub fn create_template_project(
    name_template: &Option<String>,
    git: bool,
    compiler: &Option<CppCompiler>,
) {
    // TODO required validate or control optionals
    info!("Create template project");
    let name = name_template.as_deref().unwrap_or("calculator");
    let resolved_compiler = compiler.clone().unwrap_or(CppCompiler::CLANG); // Deref ??? and not clone?

    let root_path = Path::new("example");
    let path_ifc = root_path.join("ifc");
    let path_src = root_path.join("src");
    let path_test = root_path.join("test");
    let path_dependencies = root_path.join("dependencies");

    create_directory(root_path);
    create_directory(&path_ifc);
    create_directory(&path_src);
    create_directory(&path_test);
    create_directory(&path_dependencies);

    let extension_ifcs = match resolved_compiler {
        CppCompiler::CLANG => "cppm",
        CppCompiler::MSVC => "ixx",
        CppCompiler::GCC => "ixx",
    };
    create_file(
        &path_ifc,
        format!("{}.{}", "math", extension_ifcs).as_str(),
        INTERFACE_MOD_FILE,
    );
    create_file(&path_src, "main.cpp", MAIN.as_bytes());
    create_file(&path_src, "math.cpp", SRC_MOD_FILE.as_bytes());
    create_file(&path_src, "math2.cpp", SRC_MOD_FILE_2.as_bytes());

    let mut zork_conf = ZORK_CONF
        .replace("<project_name>", name)
        .replace("<autog_test>", name)
        .replace("<autogenerated_executable>", name);

    if cfg!(windows) {
        zork_conf = zork_conf.replace("libcpp", "stdlib")
    }
    create_file(
        &PathBuf::from_str(root_path.to_str().unwrap())
            .expect("Not valid path to generate zork.conf"),
        "zork.conf",
        zork_conf.as_bytes(),
    );

    if git {
        let result_git_init = Command::new("git")
            .current_dir(&root_path)
            .arg("init")
            .spawn();

        match result_git_init {
            Ok(_children) => {
                log::info!("Created git repository")
            }
            Err(_) => {
                log::error!("Error create git respotory")
            }
        }
    }
}

const INTERFACE_MOD_FILE: &'static [u8] = "
export module math;
export namespace math {
    int sum(int num1, int num2);
    int multiply(int num1, int num2);
    int substract(int num1, int num2);
    int divide(int num1, int num2);
}
"
.as_bytes();

const SRC_MOD_FILE: &'static str = "
module math;
// Implementation of the definitions on the module unit interface
// for the sum and multiply math operations
namespace math {
    int sum(int num1, int num2) {
        return num1 + num2;
    }
    int multiply(int num1, int num2) {
        return num1 * num2;
    }
}
";

const SRC_MOD_FILE_2: &'static str = "
module math;
// Implementation of the definitions on the module unit interface
// for the substract and divide math operations
namespace math {
    int substract(int num1, int num2) {
        return num1 - num2;
    }
    int divide(int num1, int num2) {
        return num1 / num2;
    }
}
";

const MAIN: &'static str = r#"
import std;
import math;
int main() {
    std::cout << "Hello from an autogenerated Zork project!" << std::endl;
    std::cout << "RESULT '+': " << math::sum(2, 8) << std::endl;
    std::cout << "RESULT '-': " << math::substract(8, 2) << std::endl;
    std::cout << "RESULT '*': " << math::multiply(2, 8) << std::endl;
    std::cout << "RESULT '/': " << math::divide(2, 2) << std::endl;
    return 0;
}
"#;

const ZORK_CONF: &'static str = r#"
#This file it's autogenerated as an example of a Zork config file
[project]
name = "calculator"
authors = [ "Zero Day Code" ]  # Replace this for the real authors
[compiler]
cpp_compiler = "clang"
cpp_standard = "20"
std_lib = "libcpp"
[build]
output_dir = "./out"
[executable]
executable_name = "<autogenerated_executable>"
sources = [
    "*.cpp"
]
auto_execute = true
[tests]
tests_executable_name = "zork_proj_tests"
sources = [
    "*.cpp"
]
auto_run_tests = true
[modules]
base_ifcs_dir = "<project_name>/ifc/"
interfaces = [ "*.cppm" ]
base_impls_dir = "<project_name>/src/"
implementations = [
    "math.cpp",
    "math2.cpp=[math]"
]
"#;

fn create_file<'a>(path: &PathBuf, name_file: &'a str, buff_write: &'a [u8]) {
    let mut file = File::create(path.join(name_file)).expect(
        format!(
            "Error create in directory: {}, file: {}",
            path.to_str().unwrap(),
            name_file
        )
        .as_str(),
    );
    file.write_all(buff_write).expect(
        format!(
            "Error write in directory: {}, file: {}",
            path.to_str().unwrap(),
            name_file
        )
        .as_str(),
    );
}

fn create_directory(path_create: &Path) {
    DirBuilder::new()
        .recursive(true)
        .create(path_create)
        .expect(format!("Error create directory: {}", path_create.to_string_lossy()).as_str())
}
